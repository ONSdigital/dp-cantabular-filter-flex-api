// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dp-cantabular-filter-flex-api/service"
	"net/http"
	"sync"
)

// Ensure, that ResponderMock does implement service.Responder.
// If this is not the case, regenerate this file with moq.
var _ service.Responder = &ResponderMock{}

// ResponderMock is a mock implementation of service.Responder.
//
// 	func TestSomethingThatUsesResponder(t *testing.T) {
//
// 		// make and configure a mocked service.Responder
// 		mockedResponder := &ResponderMock{
// 			BytesFunc: func(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, bytes []byte)  {
// 				panic("mock out the Bytes method")
// 			},
// 			ErrorFunc: func(contextMoqParam context.Context, responseWriter http.ResponseWriter, err error)  {
// 				panic("mock out the Error method")
// 			},
// 			JSONFunc: func(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, ifaceVal interface{})  {
// 				panic("mock out the JSON method")
// 			},
// 			StatusCodeFunc: func(responseWriter http.ResponseWriter, n int)  {
// 				panic("mock out the StatusCode method")
// 			},
// 		}
//
// 		// use mockedResponder in code that requires service.Responder
// 		// and then make assertions.
//
// 	}
type ResponderMock struct {
	// BytesFunc mocks the Bytes method.
	BytesFunc func(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, bytes []byte)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(contextMoqParam context.Context, responseWriter http.ResponseWriter, err error)

	// JSONFunc mocks the JSON method.
	JSONFunc func(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, ifaceVal interface{})

	// StatusCodeFunc mocks the StatusCode method.
	StatusCodeFunc func(responseWriter http.ResponseWriter, n int)

	// calls tracks calls to the methods.
	calls struct {
		// Bytes holds details about calls to the Bytes method.
		Bytes []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ResponseWriter is the responseWriter argument value.
			ResponseWriter http.ResponseWriter
			// N is the n argument value.
			N int
			// Bytes is the bytes argument value.
			Bytes []byte
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ResponseWriter is the responseWriter argument value.
			ResponseWriter http.ResponseWriter
			// Err is the err argument value.
			Err error
		}
		// JSON holds details about calls to the JSON method.
		JSON []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ResponseWriter is the responseWriter argument value.
			ResponseWriter http.ResponseWriter
			// N is the n argument value.
			N int
			// IfaceVal is the ifaceVal argument value.
			IfaceVal interface{}
		}
		// StatusCode holds details about calls to the StatusCode method.
		StatusCode []struct {
			// ResponseWriter is the responseWriter argument value.
			ResponseWriter http.ResponseWriter
			// N is the n argument value.
			N int
		}
	}
	lockBytes      sync.RWMutex
	lockError      sync.RWMutex
	lockJSON       sync.RWMutex
	lockStatusCode sync.RWMutex
}

// Bytes calls BytesFunc.
func (mock *ResponderMock) Bytes(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, bytes []byte) {
	if mock.BytesFunc == nil {
		panic("ResponderMock.BytesFunc: method is nil but Responder.Bytes was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		N               int
		Bytes           []byte
	}{
		ContextMoqParam: contextMoqParam,
		ResponseWriter:  responseWriter,
		N:               n,
		Bytes:           bytes,
	}
	mock.lockBytes.Lock()
	mock.calls.Bytes = append(mock.calls.Bytes, callInfo)
	mock.lockBytes.Unlock()
	mock.BytesFunc(contextMoqParam, responseWriter, n, bytes)
}

// BytesCalls gets all the calls that were made to Bytes.
// Check the length with:
//     len(mockedResponder.BytesCalls())
func (mock *ResponderMock) BytesCalls() []struct {
	ContextMoqParam context.Context
	ResponseWriter  http.ResponseWriter
	N               int
	Bytes           []byte
} {
	var calls []struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		N               int
		Bytes           []byte
	}
	mock.lockBytes.RLock()
	calls = mock.calls.Bytes
	mock.lockBytes.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *ResponderMock) Error(contextMoqParam context.Context, responseWriter http.ResponseWriter, err error) {
	if mock.ErrorFunc == nil {
		panic("ResponderMock.ErrorFunc: method is nil but Responder.Error was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		Err             error
	}{
		ContextMoqParam: contextMoqParam,
		ResponseWriter:  responseWriter,
		Err:             err,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(contextMoqParam, responseWriter, err)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//     len(mockedResponder.ErrorCalls())
func (mock *ResponderMock) ErrorCalls() []struct {
	ContextMoqParam context.Context
	ResponseWriter  http.ResponseWriter
	Err             error
} {
	var calls []struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		Err             error
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// JSON calls JSONFunc.
func (mock *ResponderMock) JSON(contextMoqParam context.Context, responseWriter http.ResponseWriter, n int, ifaceVal interface{}) {
	if mock.JSONFunc == nil {
		panic("ResponderMock.JSONFunc: method is nil but Responder.JSON was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		N               int
		IfaceVal        interface{}
	}{
		ContextMoqParam: contextMoqParam,
		ResponseWriter:  responseWriter,
		N:               n,
		IfaceVal:        ifaceVal,
	}
	mock.lockJSON.Lock()
	mock.calls.JSON = append(mock.calls.JSON, callInfo)
	mock.lockJSON.Unlock()
	mock.JSONFunc(contextMoqParam, responseWriter, n, ifaceVal)
}

// JSONCalls gets all the calls that were made to JSON.
// Check the length with:
//     len(mockedResponder.JSONCalls())
func (mock *ResponderMock) JSONCalls() []struct {
	ContextMoqParam context.Context
	ResponseWriter  http.ResponseWriter
	N               int
	IfaceVal        interface{}
} {
	var calls []struct {
		ContextMoqParam context.Context
		ResponseWriter  http.ResponseWriter
		N               int
		IfaceVal        interface{}
	}
	mock.lockJSON.RLock()
	calls = mock.calls.JSON
	mock.lockJSON.RUnlock()
	return calls
}

// StatusCode calls StatusCodeFunc.
func (mock *ResponderMock) StatusCode(responseWriter http.ResponseWriter, n int) {
	if mock.StatusCodeFunc == nil {
		panic("ResponderMock.StatusCodeFunc: method is nil but Responder.StatusCode was just called")
	}
	callInfo := struct {
		ResponseWriter http.ResponseWriter
		N              int
	}{
		ResponseWriter: responseWriter,
		N:              n,
	}
	mock.lockStatusCode.Lock()
	mock.calls.StatusCode = append(mock.calls.StatusCode, callInfo)
	mock.lockStatusCode.Unlock()
	mock.StatusCodeFunc(responseWriter, n)
}

// StatusCodeCalls gets all the calls that were made to StatusCode.
// Check the length with:
//     len(mockedResponder.StatusCodeCalls())
func (mock *ResponderMock) StatusCodeCalls() []struct {
	ResponseWriter http.ResponseWriter
	N              int
} {
	var calls []struct {
		ResponseWriter http.ResponseWriter
		N              int
	}
	mock.lockStatusCode.RLock()
	calls = mock.calls.StatusCode
	mock.lockStatusCode.RUnlock()
	return calls
}
